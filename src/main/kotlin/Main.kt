@file:Suppress(
    "UNUSED_VARIABLE", "MemberVisibilityCanBePrivate", "unused",
    "ReplaceManualRangeWithIndicesCalls", "ReplaceSizeZeroCheckWithIsEmpty",
    "SameParameterValue", "UnnecessaryVariable"
)

package com.jimandreas

import kotlinx.serialization.json.Json
import java.io.File

fun main() {
//    var filePath = "C:/a/ARC-AGI/data/training/00d62c1b.json"
    val filePath = "C:/a/ARC-AGI/data/evaluation/00dbd492.json"
    val file = File(filePath)
    val exists =  file.exists()
    val isAFile = file.isFile
    val canRead = file.canRead()

    val foo = exists && isAFile && canRead

    val myData = Json.decodeFromString<TrainingData>(file.readText())

    prettyPrintProblem(myData)

    println("Done\n")
}

/**
 * first iteration on pretty printing a problem matrix
 */
fun prettyPrintProblem(td: TrainingData) {
    val iter = td.train.iterator().withIndex()

    for (t in td.train) {
        val nextTrainingArray = iter.next()
        println(nextTrainingArray.index)

        val te = nextTrainingArray.value
        val rowInputIter = te.input.iterator()
        val rowOutputIter = te.output.iterator()

        while (rowInputIter.hasNext()) {
            val s = StringBuilder()
            val rIn = rowInputIter.next()
            val rOut = rowOutputIter.next()
            val str = StringBuilder()
            s.append(rIn.joinToString(" "))
            s.append(" | ")
            s.append(rOut.joinToString(" "))
            println(s)
        }


    }

    /**
     * code generated by Google Gemini in response to this prompt:
     * Please assume kotlin.  A matrix is given in the form of integers
     * in List<List<Int>>.   Therefore it is a two dimensional matrix.
     * Assume an int with value of zero is a background.  Please write a
     * function that can trace around entries with non-zero values to find
     * an isolated matrix “entity”.  Please create a set of (row, column)
     * pairs that list the coordinates of the isolated entity.
     * The entity should be surrounded by either (1) the edge of the matrix,
     * or (2) values of zero.  Thus this is an isolated form in the matrix.
     */
    fun findIsolatedEntity(matrix: List<List<Int>>): Set<Pair<Int, Int>> {
        val entityCoordinates = mutableSetOf<Pair<Int, Int>>()
        val numRows = matrix.size
        val numCols = matrix[0].size

        fun isBoundary(row: Int, col: Int): Boolean {
            return row == 0 || row == numRows - 1 || col == 0 || col == numCols - 1
        }

        fun exploreEntity(row: Int, col: Int) {
            if (row in 0 until numRows && col in 0 until numCols && matrix[row][col] != 0 && Pair(row, col) !in entityCoordinates) {
                entityCoordinates.add(Pair(row, col))
                exploreEntity(row + 1, col)
                exploreEntity(row - 1, col)
                exploreEntity(row, col + 1)
                exploreEntity(row, col - 1)
            }
        }

        fun neighborsAreZero(matrix: List<List<Int>>, row: Int, col: Int): Boolean {
            val numRows2 = matrix.size
            val numCols2 = matrix[0].size
            return (row - 1 < 0 || matrix[row - 1][col] == 0) &&
                    (row + 1 >= numRows2 || matrix[row + 1][col] == 0) &&
                    (col - 1 < 0 || matrix[row][col - 1] == 0) &&
                    (col + 1 >= numCols2 || matrix[row][col + 1] == 0)
        }

        for (row in 0 until numRows) {
            for (col in 0 until numCols) {
                if (matrix[row][col] != 0 && (isBoundary(row, col) || neighborsAreZero(matrix, row, col))) {
                    exploreEntity(row, col)
                    return entityCoordinates // Assuming only one isolated entity
                }
            }
        }

        return entityCoordinates // Return empty set if no entity is found
    }



    /*
    Use code with caution.

    Explanation:

    findIsolatedEntity(matrix) function:

    Takes the matrix (List<List<Int>>) as input.
    Creates a mutableSetOf<Pair<Int, Int>> to store the coordinates of the isolated entity.
    Gets the number of rows and columns from the matrix.
    isBoundary(row, col) function:

    Checks if a given cell (row, col) is on the boundary of the matrix.
    neighborsAreZero(matrix, row, col) function:

    Checks if all the immediate neighbors (up, down, left, right) of a given cell are zero.
    exploreEntity(row, col) function (recursive):

    This is a recursive function that explores the connected non-zero cells to find the complete entity.
    It takes the current cell's row and column as input.
    It checks if the cell is within bounds, has a non-zero value, and hasn't been visited before.
    If all conditions are true, it adds the cell's coordinates to the entityCoordinates set and recursively calls itself for the neighboring cells.
    Main loop in findIsolatedEntity:

    Iterates through each cell in the matrix.
    If a cell has a non-zero value and is either on the boundary or surrounded by zeros, it calls exploreEntity to start exploring the entity from that cell.
    Returns the entityCoordinates set, which contains the coordinates of the isolated entity.
    Example Usage:

    Kotlin
    fun main() {
        val matrix = listOf(
            listOf(0, 0, 0, 0, 0),
            listOf(0, 1, 1, 0, 0),
            listOf(0, 1, 1, 0, 0),
            listOf(0, 0, 0, 2, 2),
            listOf(0, 0, 0, 0, 0)
        )

        val isolatedEntity = findIsolatedEntity(matrix)
        println(isolatedEntity)
        // Expected output: [(1, 1), (1, 2), (2, 1), (2, 2)]
    }

     */
}